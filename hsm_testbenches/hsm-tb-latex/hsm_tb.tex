%
% Portuguese-BR vertion
% 
\documentclass[a4paper]{article}

\usepackage{hsm_tb}
% Use longtable if you want big tables to split over multiple pages.
% \usepackage{longtable}
\usepackage[utf8]{inputenc} 
\usepackage[spanish]{babel} % Uncomment for portuguese
\usepackage{pgfgantt}
\usepackage{pdflscape}

\sloppy

\graphicspath{{./pictures/}} % Pictures dir
\makeindex
\begin{document}

\DocumentTitle{Documento de Pruebas de Proyecto}
\Project{Módulo hardware de criptografía ligera orientado al internet de las cosas}
\Organization{CIATEQ}
\Version{Versión 1.0a}

\capa
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Revision History
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{\center Histórico de Revisiones}
  \vspace*{1cm}
  \begin{table}[ht]
    \centering
    \begin{tabular}[pos]{|m{2cm} | m{7.2cm} | m{3.8cm}|} 
      \hline
      \cellcolor[gray]{0.9}
      \textbf{Date} & \cellcolor[gray]{0.9}\textbf{Descripción} & \cellcolor[gray]{0.9}\textbf{Autor(es)}\\ \hline
      \hline
      \small xx/xx/xxxx & \small <Descripción> & \small <Autor(es)> \\ \hline      
      \small xx/xx/xxxx &
      \begin{small}
        \begin{itemize}
          \item item;
          \item item;
        \end{itemize}
      \end{small} & \small <Autor(es)> \\ \hline 
    \end{tabular}
  \end{table}

\newpage

% TOC instantiation
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Document main content
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introducción}

\subsection{Vista General del Documento}
En este documento se redacta la información necesaria para realizar las pruebas al módulo hardware para seguridad basado en el estándar~\cite{1059-1993-std:1994}.

  \begin{itemize}
   \item \textbf{Requisitos funcionales -} Lista de todos los requisitos funcionales.
   \item \textbf{Requisitos no funcionales -} Lista de todos los requisitos no Funcionales.
   \item \textbf{Dependencias -} Conjunto de dependencias de IP-cores previstos.
   \item \textbf{Notas -} Lista de notas presentadas en el documento.
   \item \textbf{Referencias -} Lista de todos los textos referenciados en el documento.
  \end{itemize}

  % inicio das definições do documento
  \subsection{Definiciones}
    \FloatBarrier
    \begin{table}[H]
      \begin{center}
        \begin{tabular}[pos]{|m{5cm} | m{9cm}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{Término} & \cellcolor[gray]{0.9}\textbf{Descripción} \\ \hline
          Requisitos Funcionales & Requisitos que hacen funcional al sistema, son las capacidades que debe tener el sistema entregado.  \\ \hline
                    Requisitos Técnicos & Requisitos del sistema que definen características referentes a técnicas, algoritmos, tecnologías y especificidades de los requerimientos funcionales.  \\ \hline
          Requisitos No Funcionales & Requisitos de los módulos entregables.  Se refieren a las capacidades no funcionales del sistema como un todo y que especifican necesidades del usuario final.  \\ \hline
          Dependencias & Requisitos de reuso de IP-cores, describiendo las funciones que cada uno de estos módulos debe realizar. \\ \hline
        \end{tabular}
      \end{center}
    \end{table}  
  % fim

  % inicio da tabela de acronimos e abreviacoes do documento
  \subsection{Acrónimos y abreviaciones}
    \FloatBarrier
    \begin{table}[H]
      \begin{center}
        \begin{tabular}[pos]{|m{2cm} | m{12cm}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{Sigla} & \cellcolor[gray]{0.9}\textbf{Descripción} \\ \hline
          FR      & Requisito Funcional  \\ \hline
                    TR      & Requisito Técnico  \\ \hline
          NFR     & Requisito No Funcional  \\ \hline
          D       & Dependencia  \\ \hline
        \end{tabular}
      \end{center}
    \end{table}  
  % fim

  % inicio da descriao de prioridades de requisitos
  \subsection{Prioridades de los Requisitos}
    \FloatBarrier
    \begin{table}[H]
      \begin{center}
        \begin{tabular}[pos]{|m{2cm} | m{12cm}|} 
          \hline
          \cellcolor[gray]{0.9}\textbf{Prioridad} & \cellcolor[gray]{0.9}\textbf{Característica} \\ \hline
          Importante     & Requisito para que el sistema sea entregado.  \\ \hline
          Esencial       & Requisito que debe ser implementado para que el sistema funcione.  \\ \hline
          Deseable       & Requisito que no compromete el funcionamiento del sistema.  \\ \hline
        \end{tabular}
      \end{center}
    \end{table}  
  % fim

  % inicio dos requisitos Funcionales
  \section{Requisitos Funcionales}
    
En un sistema HSM, un controlador maestro envía peticiones de servicios continuamente al HSM, entonces, el HSM responde a dichas peticiones con servicios de seguridad. Debido a que hay muchas solicitudes del controlador maestro, el HSM debe responder a las solicitudes muy rápidamente. Para este propósito, el microcontrolador y otros módulos FPGA deben estar altamente optimizados~\cite{evita-hsm:2012}. 

En esta etapa del desarrollo del HSM, no se determina cómo tomará forma el progreso del software que utilizará los servicios del HSM, los requisitos existentes definen las funcionalidades del sistema y los algoritmos que se implementarán en FPGA para el cifrado, el \textit{hashing}, firma digital y la generación de llaves.

    \subsection{Requisitos Funcionales}
    \begin{functional}
     % format \requirement{name}{description}{priority}
     \requirement{fr1}
          {Cada llave debe ser usada por una sola función criptográfica}
      {The HSM ensures that each cryptographic key is only used for a single cryptographic function and only for its intended purpose.}
      {Importante}
    
     \requirement{fr2}
      {Cálculo de resumen (\textit{hash}) de mensajes}
      {permite la generación y verificación firmas digitales hash y adicionalmente HMAC.}
      {Importante}
            
     \requirement{fr3}
      {Cifrado asimétrico}
      {Descripción breve y objetiva.}
      {Importante}
            
     \requirement{fr4}
      {Cifrado simétrico}
      {Descripción breve y objetiva.}
      {Importante}
            
     \requirement{fr5}
      {Cálculo de números pseudo-aleatorios}
      {Descripción breve y objetiva.}
      {Importante}
            
            \requirement{fr6}
            {Proveer un contador monotónico}
            {Descripción breve y objetiva.}
            {Importante}
            
            \requirement{fr7}
            {Creación de llaves internamente}
            {Descripción breve y objetiva.}
            {Importante}
            
    \end{functional}

  \subsection{Requisitos Técnicos de los Requisitos Funcionales}
  
    \begin{technical}
      \techrequirement
            {Requisitos Técnicos de FR\ref{fr1}}
            {
      \begin{itemize}
        \item[$-$]{Los datos que serán utilizados llegan bloque a bloque al HSM}
        \item[$-$]{El algoritmo utilizado es SHA-256}
                \item[$-$]{El \textit{hash} se envía a una dirección especificada previamente}
      \end{itemize}
      }
            
      \techrequirement
            {Requisitos Técnicos de FR\ref{fr2}}
      {
      \begin{itemize}
        \item[$-$]{Los datos que serán utilizados llegan bloque a bloque al HSM}
        \item[$-$]{El algoritmo utilizado es SHA-256}
                \item[$-$]{El \textit{hash} se envía a una dirección especificada previamente}
      \end{itemize}
      }
            
      \techrequirement
      {Requisitos Técnicos de FR\ref{fr3}}
      {
      \begin{itemize}
        \item[$-$]{El algoritmo utilizado es AES-128}
      \end{itemize}
      }
            
      \techrequirement
      {Requisitos Técnicos de FR\ref{fr4}}
      {
      \begin{itemize}
        \item[$-$]{Los datos que serán utilizados llegan bloque a bloque al HSM}
        \item[$-$]{El algoritmo utilizado es SHA-256}
                \item[$-$]{El \textit{hash} se envía a una dirección especificada previamente}
      \end{itemize}
      }
            
      \techrequirement
      {Requisitos Técnicos de FR\ref{fr5}}
      {
      \begin{itemize}
        \item[$-$]{Los datos que serán utilizados llegan bloque a bloque al HSM}
        \item[$-$]{El algoritmo utilizado es SHA-256}
                \item[$-$]{El \textit{hash} se envía a una dirección especificada previamente}
      \end{itemize}
      }
            
            \techrequirement
            {Requisitos Técnicos de FR\ref{fr6}}
      {
      \begin{itemize}
        \item[$-$]{Los datos que serán utilizados llegan bloque a bloque al HSM}
        \item[$-$]{El algoritmo utilizado es SHA-256}
                \item[$-$]{El \textit{hash} se envía a una dirección especificada previamente}
      \end{itemize}
      }
            
            \techrequirement
            {Requisitos Técnicos de FR\ref{fr7}}
      {
      \begin{itemize}
        \item[$-$]{Los datos que serán utilizados llegan bloque a bloque al HSM}
        \item[$-$]{El algoritmo utilizado es SHA-256}
        \item[$-$]{El \textit{hash} se envía a una dirección especificada previamente}
      \end{itemize}
      }
    \end{technical}    
 
\section{Requisitos no Funcionales}
% Esta seção apresenta a lista de Requisitos No Funcionales do projeto.

  \begin{nonfunctional}
    \requirement{nfr1}
    {Nombre del Requisito}
    {Descripción breve y objetiva.}
    {Importante}

    \requirement{nfr2}
    {Nombre del Requisito}
    {Descripción breve y objetiva.}
    {Importante}
  \end{nonfunctional}

\section{Dependencias}
  % Esta seção apresenta uma lista dos IP-cores disponíveis % para reuso e que devem ser adotados no desenvolvimento % deste projeto.

  \begin{dependencies}
    \dependency{Nombre del IP-\textit{core}}
        {Descripción breve y objetiva del IP-\textit{core} y referencia al documento.}
    \dependency{Nombre del IP-\textit{core}}
        {Descripción breve y objetiva del IP-\textit{core} y referencia al documento.}
  \end{dependencies}  

\section{Arquitectura del sistema}

Un HSM (\textit{Hardware Security Module}) es un procesador criptográfico seguro con el objetivo principal de administrar llaves criptográficas y ofrecer operaciones criptográficas aceleradas utilizando dichas llaves. Los HSM suelen ofrecer mecanismos de protección de la información como autenticación robusta y resistencia al sabotaje físico. Las características principales de un HSM incluyen almacenamiento y generación de llaves, cifrado simétrico y asimétrico acelerado y copia de seguridad de material sensible mediante cifrado \cite{mtreviewhsm:2010}. 

Los HSMs se existen en diferentes configuraciones, los tipos de HSM comunes en sistemas embebidos se encuentran en forma de coprocesadores conectados mediante un bus directamente al microcontrolador o como un componente más del microcontrolador, en la Figura  ~\ref{fig:hsm_general} se presenta el esquema general de la arquitectura propuesta en este proyecto.
 
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{pictures/hsm_architecture.png}
  \caption{Esquema general de un HSM para sistema embebido.}
  \label{fig:hsm_general}
\end{figure}


\begin{landscape}

\section{Planeación}

\begin{ganttchart}[
        title/.append style={fill=black!10},
        x unit=3pt,
        %compress calendar,
        time slot format=simple,
        ]{1}{140}
    \small
    \gantttitle{2019}{84}
    \gantttitle{2020}{56} \\
    \gantttitle{Octubrer}{28}
    \gantttitle{Noviembre}{28}
    \gantttitle{Diciembre}{28}
    \gantttitle{Enero}{28}
    \gantttitle{Febrero}{28}\\
    \gantttitle{W1}{7}
    \gantttitle{W2}{7}
    \gantttitle{W3}{7}
    \gantttitle{W4}{7}
    \gantttitle{W5}{7}
    \gantttitle{W6}{7}
    \gantttitle{W7}{7} 
    \gantttitle{W8}{7}
    \gantttitle{W9}{7}
    \gantttitle{W10}{7}
    \gantttitle{W11}{7}
    \gantttitle{W12}{7}
    \gantttitle{W13}{7}
    \gantttitle{W14}{7}
    \gantttitle{W15}{7}
    \gantttitle{W16}{7}
    \gantttitle{W17}{7}
    \gantttitle{W18}{7}
    \gantttitle{W19}{7}
    \gantttitle{W20}{7}\\

\ganttbar{Revisión del fundamento teórico}{3}{6}\\
\ganttbar{Propuesta de proyecto}{7}{10}\\
\ganttbar{Detalle de requerimientos}{7}{10}\\
\ganttbar{Revisión del estado del arte}{11}{14}\\
\ganttbar{Elaboración de hipótesis}{15}{18}\\
\ganttbar{Elaboración de objetivos}{16}{22}\\
\ganttbar{Diseño del sistema}{16}{22}\\
\ganttbar{Especificación del sistema}{16}{22}\\
\ganttbar{Pruebas unitarias}{16}{22}\\
\ganttbar{Pruebas de integración}{16}{22}\\
\ganttbar{Redacción de resultados}{16}{22}\\
\end{ganttchart}
\end{landscape}

\section{Vista general de UVM}

The Universal Verification Methodology (UVM) that can improve interoperability, reduce the cost of using intellectual property (IP) for new projects or electronic design automation (EDA) tools, and make it easier to reuse verification components is provided. Overall, using this standard will lower verification costs and improve design quality throughout the industry. The primary audiences for this standard are the implementors of the UVM base class library, the implementors of tools supporting the UVM base class library, and the users of the UVM base class library.

Role of each testbench element is explained below,
UVM test
The test is the topmost class. the test is responsible for,

configuring the testbench.
Initiate the testbench components construction process by building the next level down in the hierarchy ex: env.
Initiate the stimulus by starting the sequence.
UVM Environment
Env or environment: The environment is a container component for grouping higher level components like agent’s and scoreboard.
UVM Agent
UVM agent groups the uvm components specific to an interface or protocol.
example: groups the components associated with BFM(Bus Functional Model).
The components of an agent are,

UVM SEQUENCE ITEM
The sequence-item defines the pin level activity generated by agent (to drive to DUT through the driver) or the activity has to be observed by agent (Placeholder for the activity monitored by the monitor on DUT signals).
UVM DRIVER
Responsible for driving the packet level data inside sequence item into pin level (to DUT).

UVM SEQUENCE
Defines the sequence in which the data items need to be generated and sent/received to/from the driver.
UVM SEQUENCER
Responsible for routing the data packet’s(sequence item) generated in sequence to the driver or vice verse.
UVM MONITOR
Observes pin level activity on interface signals and converts into packet level which is sent to components such as scoreboards.
UVM Scoreboard
Receives data item’s from monitor’s and compares with expected values.

expected values can be either golden reference values or generated from the reference model.

\section{Herramienta de pruebas \textit{toolchain}}

\section{Pruebas unitarias}

\section{Pruebas de integración}

\section{Pruebas de sistema}

\section{Análisis con herramientas \textit{Lint}}

\subsection{Verilator}

 What Verilator Does
Verilator is invoked with parameters similar to GCC or Synopsys’s VCS. It "Verilates" the specified synthesizable Verilog or SystemVerilog code by reading it, performing lint checks, and optionally inserting assertion checks and coverage-analysis points. It outputs single- or multi-threaded .cpp and .h files, the "Verilated" code.

The user writes a little C++/SystemC wrapper file, which instantiates the "Verilated" model of the user’s top level module. These C++/SystemC files are then compiled by a C++ compiler (gcc/clang/MSVC++). The resulting executable performs the design simulation. Verilator also supports linking its generated libraries, optionally encrypted, into other simulators.

Verilator may not be the best choice if you are expecting a full featured replacement for NC-Verilog, VCS or another commercial Verilog simulator, or if you are looking for a behavioral Verilog simulator e.g. for a quick class project (we recommend Icarus Verilog for this.) However, if you are looking for a path to migrate synthesizable Verilog to C++ or SystemC, and your team is comfortable writing just a touch of C++ code, Verilator is the tool for you.

go to https://www.veripool.org/projects/verilator/wiki/Installing

  \begin{figure}[h]
    \includegraphics[width=0.6\linewidth]{pictures/uvm.png}
    \label{uvm_tb}
  \end{figure}
        
% Optional bibliography section
% To use bibliograpy, first provide the ipprocess.bib file on the root folder.
\newpage
\bibliographystyle{ieeetr}
\bibliography{bibliography}

\end{document}
